# Identity types, with based path induction.
:assume Id : Π (A : Type). A → A → Type
:assume refl : Π (A : Type, a : A). a = a
:assume ind-Id : Π (A : Type, a : A).
    Π (C : Π (b : A). a = b → Type).
    C(a, refl(A, a)) →
    Π (b : A, p : a = b). C(b, p)
:assume ind-Id-refl : Π (A : Type, a : A).
    Π (C : Π (b : A). a = b → Type).
    Π (c : C(a, refl(A, a))).
    ind-Id(A, a, C, c, a, refl(A, a)) = c

# Dependent sum type.
:assume Σ' : Π (A : Type, B : A → Type). Type
:assume pair : Π (A : Type, B : A → Type, a : A, b : B(a)). Σ (a : A). B(a) 
:assume ind-Σ : Π (A : Type, B : A → Type).
    Π (C : (Σ (a : A). B(a)) → Type).
    (Π (a : A, b : B(a)). C(pair(A, B, a, b))) →
    Π (p : Σ (a : A). B(a)). C(p)
:assume ind-Σ-pair : Π (A : Type, B : A → Type).
    Π (C : (Σ (a : A). B(a)) → Type).
    Π (c : Π (a : A, b : B(a)). C(pair(A, B, a, b))).
    Π (a : A, b : B(a)). 
    ind-Σ(A, B, C, c, pair(A, B, a, b)) = c(a, b)

# Empty type.
:assume 0 : Type
:assume ind0 : Π (C : 0 → Type, a : 0). C(a)

# Unit type.
:assume 1 : Type
:assume tt : 1
:assume ind-1 : Π (C : 1 → Type). C(tt) → Π (a : 1). C(a)
:assume ind-1-tt : Π (C : 1 → Type, c : C(tt)). ind-1(C, c, tt) = c

# Boolean type.
:assume 2 : Type
:assume 0₂ : 2
:assume 1₂ : 2
:assume ind-2 : Π (C : 2 → Type). C(0₂) → C(1₂) → Π (a : 2). C(a)
:assume ind-2-0₂ : Π (C : 2 → Type, c₀ : C(0₂), c₁ : C(1₂)). ind-2(C, c₀, c₁, 0₂) = c₀
:assume ind-2-1₂ : Π (C : 2 → Type, c₀ : C(0₂), c₁ : C(1₂)). ind-2(C, c₀, c₁, 1₂) = c₁

# Structure of identity types.
ap(A : Type, B : Type, f : A → B) : Π (x : A, y : A). x = y → f(x) = f(y)
    := λ (x : A). ind-Id(A, x, _, refl(_, _))
subst(A : Type, B : A → Type) : Π (x : A, y : A). x = y → B(x) → B(y)
    := λ (x : A). ind-Id(A, x, _, λ (b : _). b)
sym(A : Type) : Π (x : A, y : A). x = y → y = x
    := λ (x : A). ind-Id(A, x, _, refl(A, x))
trans(A : Type, x : A, y : A, z : A) : x = y → y = z → x = z
    := λ (p : x = y, q : y = z).
        ind-Id(A, x, λ (y : A, p : x = y). Π (z : A). y = z → x = z, ind-Id(A, x, _, refl(A, x)), y, p)(z, q)

# Function types.
happly(A : Type, B : Type) : Π (f : A → B, g : A → B). f = g → Π (x : A). f(x) = g(x)
    := λ (f : A → B). ind-Id(A → B, f, _, λ (x : A). refl(B, f(x)))

# Sigma types.
# TODO: use (a, b) instead of pair(A, B, a, b) when eta rule is strong enough
π₁(A : Type, B : A → Type) : (Σ (a : A). B(a)) → A
    := ind-Σ(A, B, _, λ (a : A, b : B(a)). a)
π₁-pair(A : Type, B : A → Type, a : A, b : B(a)) : π₁(A, B, pair(A, B, a, b)) = a
    := ind-Σ-pair(A, B, _, _, a, b)
π₂(A : Type, B : A → Type) : Π (p : Σ (a : A). B(a)). B(π₁(A, B, p))
    := ind-Σ(A, B, _, λ (a : A, b : B(a)). subst(A, B, _, _, sym(A, _, _, π₁-pair(A, B, a, b)), b))
π₂-pair(A : Type, B : A → Type, a : A, b : B(a)) : π₂(A, B, pair(A, B, a, b)) = subst(A, B, _, _, sym(A, _, _, π₁-pair(A, B, a, b)), b)
    := ind-Σ-pair(A, B, _, _, a, b)

# Sets and logic.
IsContr(A : Type) := Σ (a : A). Π (x : A). a = x
IsProp(A : Type) := Π (x : A, y : A). x = y
